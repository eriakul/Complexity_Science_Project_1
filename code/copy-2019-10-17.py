# -*- coding: utf-8 -*-
"""Project (1)

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qHE_7uzUuapyvPopHZasglpOhaXCB2EG
"""

import gdown
import csv
import networkx as nx
import numpy as np
from random import choice


def load_data_from_drive():

    edges = {}
    gdown.download(
        "https://drive.google.com/uc?id=1vBUOcQVh1EDY91xtW4fZjowbN8RFQ5Br",
        "interactions.txt",
        quiet=True,
    )
    with open("interactions.txt") as f:
        c = csv.reader(f, delimiter="\t")
        for row in c:
            pair = (int(row[0]), int(row[1]))
            edges[pair] = edges.get(pair, 0) + (float(row[2]) / 3)

    people = {}
    gdown.download(
        "https://drive.google.com/uc?id=10e8tFloUoUpV8UUf863blJBk8eTrSUih",
        "person_descriptions.txt",
        quiet=True,
    )
    with open("person_descriptions.txt") as f:
        c = csv.reader(f, delimiter="\t")
        for row in c:
            people[int(row[0])] = row[1]

    edges_list = [(key[0], key[1], value) for key, value in edges.items()]
    return edges_list, people


from numpy.random import choice

edges, people = load_data_from_drive()
# edges = edges[:100]
# print(edges)
# eIndexes = choice(len(edges), 100)
# edges = np.array(edges)
# edges = edges[[eIndexes]]
# print(edges)


class Graphs:
    def make_data_driven_graph(self, edges, people, status):
        G = nx.Graph()
        G.add_nodes_from(
            [(name, dict(state=status.S, job=job)) for name, job in people.items()]
        )
        G.add_weighted_edges_from(edges)
        #       G.remove_nodes_from(list(nx.isolates(G)))
        return G

    def adjacent_edges(self, nodes, halfk):
        n = len(nodes)
        for i, u in enumerate(nodes):
            for j in range(i + 1, i + halfk + 1):
                v = nodes[j % n]
                yield u, v

    def make_ring_lattice(self, n, k):
        G = nx.Graph()
        nodes = range(n)
        G.add_nodes_from(nodes)
        G.add_edges_from(self.adjacent_edges(nodes, k // 2))
        return G

    def make_ws_graph(self, n, k, p):
        def flip(p):
            return np.random.random() < p

        G = self.make_ring_lattice(n, k)
        nodes = set(G)
        for u, v in G.edges():
            if flip(p):
                choices = nodes - {u} - set(G[u])
                new_v = np.random.choice(list(choices))
                G.remove_edge(u, v)
                G.add_edge(u, new_v)
        return G


class Status:
    def __init__(self):
        self.S = "susceptible"
        self.E = "exposed"
        self.I = "infectious"
        self.R = "recovered"


class School(Graphs):
    def __init__(self, edges, people):
        super()
        self.status = Status()

        self.G = self.make_data_driven_graph(edges, people, self.status)
        self.sickNodes = []

    def randomly_expose(self):
        unluckyOne = choice(self.G.nodes)
        print("Person {} has become exposed to the disease.".format(unluckyOne))
        self.expose(unluckyOne)

    def transmit_p(self, weight, showSymptoms=False):
        """
      Randomly returns True or False with a probability that models the
      chance of an influenza infection travelling along a link with a
      given weight, measured in CPRs (20s, or 1/3 minutes).
      """
        p = 1 - np.power(1 - 0.003, weight)

        if showSymptoms:
            p = 0.25 * p

        return np.random.random() < p

    def start_showing_symptoms(self):
        p = 0.5
        return np.random.random() < p

    def step(self):
        toExpose = set()
        toInfect = set()
        toRecover = set()

        for sickNode in self.sickNodes:
            state = self.G.node[sickNode]["state"]
            for neighbor, weight in self.get_neighbors_weights(sickNode):
                neighborState = self.G.node[neighbor]["state"]
                if neighborState == self.status.S:
                    if self.transmit_p(weight, showSymptoms=state == self.status.I):
                        toExpose.add(neighbor)
            if state == self.status.E:
                if self.start_showing_symptoms():
                    toInfect.add(sickNode)
            if state == self.status.I:
                toRecover.add(sickNode)

        for node in toExpose:
            self.expose(node)

        for node in toInfect:
            self.infect(node)

        for node in toRecover:
            self.recover(node)

    def get_neighbors_weights(self, node):
        arr = []
        for n in self.G.neighbors(node):
            arr.append((n, self.G.edges[(node, n)]["weight"]))
        return arr

    def expose(self, index):
        self.G.node[index]["state"] = self.status.E
        self.sickNodes.append(index)

    def infect(self, index):
        self.G.node[index]["state"] = self.status.I

    def recover(self, index):
        self.G.node[index]["state"] = self.status.R
        self.sickNodes.remove(index)

    def get_colors(self):
        def color(state):
            if state == "susceptible":
                return "green"
            elif state == "exposed":
                return "yellow"
            if state == "infectious":
                return "red"
            if state == "recovered":
                return "blue"

        states = list([data["state"] for i, data in self.G.nodes(data=True)])
        return list(map(color, states))

    def get_global_state(self):
        globalState = {}
        for index, attributes in self.G.nodes(data=True):
            state = attributes["state"]
            globalState[state] = globalState.get(state, 0) + 1

        return globalState

    def get_global_state_jobs(self):
        globalState = {}
        for index, attributes in self.G.nodes(data=True):
            state = attributes["state"]
            job = attributes["job"]
            globalState[(state, job)] = globalState.get((state, job), 0) + 1

        return globalState

    def visualize(self):
        nx.draw_networkx(
            self.G, node_color=self.get_colors(), node_size=5, with_labels=False
        )
        print(self.get_global_state())


S = School(edges, people)
S.randomly_expose()

print(S.get_global_state_jobs())
S.step()
# S.visualize()

import matplotlib.pyplot as plt

steps = 15
time = range(steps)
Sch = School(edges, people)
Sch.randomly_expose()

S = []
E = []
I = []
R = []

St = []
Et = []
It = []
Rt = []


for i in time:
    state = Sch.get_global_state_jobs()

    S.append(state.get(("susceptible", "student"), 0))
    E.append(state.get(("exposed", "student"), 0))
    I.append(state.get(("infectious", "student"), 0))
    R.append(state.get(("recovered", "student"), 0))

    St.append(state.get(("susceptible", "teacher"), 0))
    Et.append(state.get(("exposed", "teacher"), 0))
    It.append(state.get(("infectious", "teacher"), 0))
    Rt.append(state.get(("recovered", "teacher"), 0))

    Sch.step()

fig, ax = plt.subplots()

sLine = ax.plot(time, S, "g", label="Susceptible")
eLine = ax.plot(time, E, "y", label="Exposed")
iLine = ax.plot(time, I, "r", label="Infectious")
rLine = ax.plot(time, R, "c", label="Recovered")


sLinet = ax.plot(time, St, "g:")
eLinet = ax.plot(time, Et, "y:")
iLinet = ax.plot(time, It, "r:")
rLinet = ax.plot(time, Rt, "c:")


ax.legend()
plt.title("SEIR High School Model - Instantaneous Time Steps")
plt.xlabel("Time Steps - 12 hr Each")
plt.ylabel("People")

plt.show()

import matplotlib.pyplot as plt

steps = 10

time = range(steps)
argAnts = []
carpAnts = []

Sch = School(edges, people)
Sch.randomly_expose()

for i in time:
    state = Sch.get_global_state()
    S.append(state.get("susceptible", 0))
    E.append(state.get("exposed", 0))
    I.append(state.get("infectious", 0))
    R.append(state.get("recovered", 0))
    Sch.step()


fig, ax = plt.subplots()

sLine = ax.plot(time, S, label="Susceptible")
eLine = ax.plot(time, E, label="Exposed")
iLine = ax.plot(time, I, label="Infectious")
rLine = ax.plot(time, R, label="Recovered")


ax.legend()
plt.title("SEIR High School Model - Instantaneous Time Steps")
plt.xlabel("Time Steps - 12 hr Each")
plt.ylabel("People")

plt.show()

Sch.visualize()
